<!DOCTYPE html>
<html lang="kr">

<head>
    <link rel="stylesheet" href="/pages/stylesheet/async.css">
    <link href="https://fonts.googleapis.com/css2?family=Odibee+Sans&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Sunflower:wght@500&display=swap" rel="stylesheet">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>juntechs blog</title>
</head>

<body>
    <header class="header">
        <div class="percent"></div>
        <nav class="menu">MENU</nav>
        <h1 class="header_maintext" onclick="location.href='../index.html'">JUNTECHS BLOG</h1>
        <h3 class="header_subtext">javascript study blog</h3>
    </header>

    <div class="main_contents">
        <div class="side_nav">
            <div class="nav_contents">
                <p4 class="index">목차</p4>
                <a href="./callstack.html" class="callback">
                    <p4 class="index_number">1.</p4> '호출스택'
                </a>
                <a href="#" class="callback">
                    <p4 class="index_number">2.</p4> 비동기 프로그래밍이란?
                </a>
                <a href="#" class="callback">
                    <p4 class="index_number">3.</p4> '원시자료형'
                </a>
            </div>
        </div>



        <div class="contents">
            <h1 class="index_text">
                <div class="chapterIndex">
                    <div class="chapterName">비동기 프로그래밍?<h4 class="small_text">( asynchronous programming )</h4>
                    </div>
                </div>
            </h1>
                <div class="direction">
                   <h1>비동기 프로그래밍이란 무엇인가?</h1>
                   <br><br>
                    <p>비동기 프로그래밍은 동기와 반대되는 의미이다. 일반적으로, 프로그램의 코드는 순차적으로 진행된다. <br>
                    예를 들면 어떠한 함수가 실행될 때, 다음 함수가 실행될려면 그 뒤에 함수는 전 함수가 실행이 완료될 때 까지 기다려야한다.
                    </p>
                    <br><br>
                    <h2>Blocking code?</h2>
                    <br>
                    <p>비동기 기법은 특히 웹 프로그래밍에서 매우 유용하다. 웹 앱이 브라우저에서 특정 코드를 실행하느라 브라우저에게 제어권을 <br>
                    돌려주지 않으면 브라우저는 멈춘 것 처럼 보인다. 이러한 현상을 <strong>blocking</strong>이라 한다. <a href="https://developer.mozilla.org/ko/docs/Learn/JavaScript/Asynchronous/Concepts">mozilla MDN</a>의 코드를 참고하겠다.
                    <br>    
                </p>
                    
                    <pre class="prettyprint">
const btn = document.querySelector('button');
btn.addEventListener('click', () => {
    let myDate;
    for(let i = 0; i < 10000000; i++) {
    let date = new Date();
    myDate = date
    }

    console.log(myDate);

    let pElem = document.createElement('p');
    pElem.textContent = 'This is a newly-added paragraph.';
    document.body.appendChild(pElem);
});</pre>
                    <br>
                    <p>이 코드를 보면 셀렉트된 button을 클릭하면 날짜를 천 만번 계산하게 되는 코드가 있다. 2-7번째 줄 까지의 코드가 진행되어 콘솔에
                        myDate가 출력되기 전까지 아래쪽 코드('This is a newly-added paragraph p태그에 생성')는 실행되지 않을 것이다. <strong>자바스크립트는 동기적</strong>이기 때문이다.
                        <br><br>
                        다음으로 두 번째 코드를 확인해보자. 역시 <a href="https://developer.mozilla.org/ko/docs/Learn/JavaScript/Asynchronous/Concepts">mozilla MDN</a>의 예제 코드이다.
                        <br>
                    </p>
                    
                    <pre class="prettyprint">
function expensiveOperation() {
    for(let i = 0; i < 1000000; i++) {
        ctx.fillStyle = 'rgba(0,0,255, 0.2)';
        ctx.beginPath();
        ctx.arc(random(0, canvas.width), random(0, canvas.height), 10, degToRad(0), degToRad(360), false);
        ctx.fill()
    }
    }
    
    fillBtn.addEventListener('click', expensiveOperation);
    
    alertBtn.addEventListener('click', () =>
    alert('You clicked me!')
    );
                    </pre>
                    <p>만약 이 코드에서 'fillBtn'을 클릭한 뒤 'alertBtn'을 클릭하면 어떻게 될까? 아마 'You clicked me!'라는
                        실행결과는 보이지 않을 것이다. 계속 말했듯 자바스크립트는 <strong>동기적</strong>이기 때문이다.
                        아직 'expensiveOperation' 함수가 실행중이기 때문에 그에 대한 콜 스택이 가득 차 'alertBtn'의 익명함수는
                        실행될 수 없는 것이다. 이에 대해서는 또다른 개념인 'Thread'가 등장하게 된다. <br><br>
                        자바스크립트는 기본적으로 'Single Thread'이기 때문에 동시다발적인 처리가 불가능하다.
                    </p> 
                    <br><br>
                    <h2>Thread</h2>
                    <br>
                    <p>쓰레드란 기본적으로 프로그램이 완료될 때 사용할 수 있는 단일 프로세스이다. 즉, 단일 쓰레드인
                        자바스크립트 언어는 한 번에 한가지의 Task밖에 처리할 수 없는 것이다. 그렇다면 어떻게 자바스크립트는
                        비동기적으로 task들을 처리할 수 있을까?
                    </p>
                    <br><br><br><br>
                    <h2>Call back이란?</h2>
                    <br>
                    <p>자바스크립트 비동기 처리의 시작은 'call back'이라고 볼 수 있다. '콜백 지옥'이라는 말을 들어본 적이
                        있을 것이다. 콜백 함수의 뜻은 거창하지 않다. '나중에 다시 불러줘!'라는 뜻이다.
                        콜백이 무조건 비동기적이진 않다. 다음의 예를 보자.
                    </p>
                    <pre class="prettyprint">
console.log('1')
console.log('3')
function printImmediately(print) {
    print();
}
// Synchronous callback
printImmediately(() => console.log('hello'))
                    </pre>
                    <br>
                    <p>이 코드의 진행을 확인해보자. 우선 'hoisting'에 의해 선언된 함수가 제일 위로 올라갈 것이다. 그 후 '1', '2'가
                    차례대로 출력되고 'hello'가 출력될 것이다. 'printImmediately'는 callback 됐지만 동기적으로 실행된 것이다.
                    <br><br>
                    자 그럼 다음으로 비동기적인 실행을 알아보자. web api에 'setTimeout'이라는 대표적인 예가 있다. 다음의 코드로 한 번
                    살펴보자.
                    </p>
                    <pre class="prettyprint">
console.log('1')
//setTimeout API
setTimeout(function() {
    console.log('2')
}, 2000)

console.log('3')
                    </pre>
                    <p>
                        이러한 코드가 있다. 우선 동기적인 자바스크립트의 흐름으로 봤을 때 이 코드는 1,2,3이 차례대로 호출되는 것이
                        맞는 것 같지만 아니다. <br>setTimeout은 web API로써 두 개의 인자를 받는데 첫번 째 인자는 실행될 함수 두 번째는
                        실행되는데 걸리는 시간을 ms단위로 넣는다.<br> 그렇게 되면 브라우저는 setTimeout에 의해 2초 뒤 익명함수에 있는
                        console.log('2')를 실행하게 되므로 1, 3, 2 순서로 출력이 될 것이다. 비동기의 시작이다.
                        <br><br>
                        자 다시한번 동기적 콜백함수와 비동기적 콜백함수를 비교해보자.
                    </p>
                    <pre class="prettyprint">
console.log('1')
console.log('2')
console.log('3')

//Asynchronous callback
function printDelay(print, timeout) {
    setTimeout(print, timeout);
}
printDelay(() => console.log('async'), 2000)

//Synchronous callback
function printImmediately(print) {
    print();
}
printImmediately(() => console.log('hello'))

                    </pre>
                    <p>코드를 살펴보면 우선 1,2,3이 차례로 출력될 것이다.
                        그리고 호이스팅에 의해 선언된 함수들이 맨 위로 올라갈 것이고
                        console.log('3') 이후에는 'printDelay'라는 콜백함수가 있다.
                        이 함수롤 보면 printDelay를 콜백한다.<br><br>
                        하지만 setTimeout에 의해 비동기 처리되어 2초 뒤에 실행이 될 것이므로
                         그 다음 콜백함수인 printImmediately가 실행된 후
                        2초 뒤에 printDelay가 실행되어 'hello'가 콘솔에 출력된 후 'async'가
                        콘솔에 출력될 것이다. <br><br>
                        만약 printDelay가 실행하는데 2초가 걸리는 함수였다고 가정하고 비동기
                        처리가 되지 않는 함수였다면 'printImmediately' 콜백함수는 printDelay가
                        마무리 되는 시간까지 실행이 될 수 없었을 것이다.
                    </p>

                </div>
            

        </div>
    </div>

    <div class="menu_bar">
        <div class="menu_box">
            <div class="close_icon">Close</div>
            <ul>
                <a href="./callstack.html">
                    <li> '호출스택'</li>
                </a>
                <li>비동기 프로그래밍이란?</li>
                <li>'원시자료형'</li>
            </ul>
        </div>
    </div>
    <footer>
        <div class="footer_contents">
            Copyright 2020. sangjuntechs. All rights reserved.
            <br>
            www.github.sangjuntechs.com
            <br>
            <br>
            devjun0421@gmail.com
        </div>
    </footer>

    <script src="../javascript/scrollPercent.js"></script>
    <script src="../javascript/slideMenu.js"></script>
    <script
        src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js?autoload=true&skin=sunburst&lang=css">
    </script>
</body>


</html>