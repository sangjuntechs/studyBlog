<!DOCTYPE html>
<html lang="kr">

<head>
    <link rel="stylesheet" href="/pages/stylesheet/async.css">
    <link href="https://fonts.googleapis.com/css2?family=Odibee+Sans&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Sunflower:wght@500&display=swap" rel="stylesheet">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>juntechs blog</title>
</head>

<body>
    <header class="header">
        <div class="percent"></div>
        <nav class="menu">MENU</nav>
        <h1 class="header_maintext" onclick="location.href='../index.html'">JUNTECHS BLOG</h1>
        <h3 class="header_subtext">javascript study blog</h3>
    </header>

    <div class="main_contents">
        <div class="side_nav">
            <div class="nav_contents">
                <p4 class="index">목차</p4>
                <a href="./callstack.html" class="callback">
                    <p4 class="index_number">1.</p4> '호출스택'
                </a>
                <a href="./async.html" class="callback">
                    <p4 class="index_number">2.</p4> 비동기 프로그래밍이란?
                </a>
                <a href="#" class="callback">
                    <p4 class="index_number">3.</p4> '원시자료형'
                </a>
            </div>
        </div>



        <div class="contents">
           
            <div class="direction">
                <h1>3. Async & await?</h1>
                <br><br>
                <p>async await 자바스크립트로 개발을 해 보았으면 한 번쯤은 보았을것이다. 우선 이러한
                    async, await 함수는 Promise를 더욱 간단하게 쓸 수 있게 해준다. then의 체이닝을
                    최소화 할 수 있다는 의미로 필자는 해석했다. <a href="https://developer.mozilla.org/ko/docs/Learn/JavaScript/Asynchronous/Async_await">
                    Mozilla MDN</a>의 예제를 살펴보자.
                </p>
                <br>
                <h2>How to write clean promise code?</h2>
                <br>
                <h3 style="color: red;">Before async, await</h3>
                <pre class="prettyprint">
fetch('coffee.jpg')
.then(response => response.blob())
.then(myBlob => {
  let objectURL = URL.createObjectURL(myBlob);
  let image = document.createElement('img');
  image.src = objectURL;
  document.body.appendChild(image);
})
.catch(e => {
  console.log('There has been a problem with your fetch operation: ' + e.message);
});                    
                </pre>
                <p>async와 await을 사용하기 전의 코드이다. 전에 살펴본 Promise를 사용해서 잘 정리했지만 연속적인
                    promise 체이닝으로 가독성이 떨어지게 된다. 이러한 코드를 우리는 async await로 더욱 예쁘게
                    코드를 정리할 수 있다.
                </p>
                <br>
                <h3 style="color: red;">after async await</h3>
                <pre class="prettyprint">
async function myFetch() {
  let response = await fetch('coffee.jpg');
  let myBlob = await response.blob();

  let objectURL = URL.createObjectURL(myBlob);
  let image = document.createElement('img');
  image.src = objectURL;
  document.body.appendChild(image);
}

myFetch()
.catch(e => {
  console.log('There has been a problem with your fetch operation: ' + e.message);
});                    
                </pre>
                <p>async 비동기 함수를 사용하기 위해선 함수의 앞에 꼭 'async'를 선언해
                    주어야 한다. await는 async로 선언된 함수블럭 스코프 안에서만 사용이
                    가능하다.
                    <br>
                    코드를 살펴보니 더이상 then을 찾아볼 수 없게 되었다. async 키워드 자체가
                    함수를 Promise로 바꾸었기 때문에 promise와 await의 하이브리드 접근 방식을
                    코드를 리팩토링 할 수 있다. 또한 then블록을 개개별로 체이닝 하는게 아니라
                    async 키워드로 함수 내부의 블럭으로 가져와 더욱 유연한 코딩이 가능하다.
                    예제를 확인해보자
                </p>
                <pre class="prettyprint">
async function myFetch() {
  let response = await fetch('coffee.jpg');
  return await response.blob();
}

myFetch().then((blob) => {
  let objectURL = URL.createObjectURL(blob);
  let image = document.createElement('img');
  image.src = objectURL;
  document.body.appendChild(image);
}).catch(e => console.log(e));                    
                </pre>
                <p>async를 사용하지 않았다면 myFetch의 then을 개개별로
                    일일이 체이닝 해야했을 것이다. 즉, async와 await을 사용하여
                    Promise의 체이닝을 최소화하여 비동기 프로그래밍을 가능하게
                    해주는 것이 async와 await이다. myFetch().then 블록이 실행되는 중
                    오류가 발생하게 된다면 .catch로 핸들링 된 에러가 출력될 것이다.
                    <br>
                    위 코드와 다른점을 살펴보면 myBlob 변수를 선언하는 대신 myFetch().then()의
                    콜백함수로 블록 안에서 처리하게 된 점이다.
                    이렇게 간단하게 우리는 비동기 프로그래밍에 대해 알아보게 되었다.
                    <br>
                    <br>
                    비동기 프로그래밍에 익숙해져 보고 싶다면, 이전 페이지의 콜백체인 함수를
                    async, await Promise를 이용하여 능동적으로 바꿔보는 것을 추천한다.

                </p>
            </div>


        </div>
    </div>
    <nav class="next_page" onclick="location.href = '#'">Next Page</nav>
    <div class="menu_bar">
        <div class="menu_box">
            <div class="close_icon">Close</div>
            <ul>
                <a href="./callstack.html">
                    <li> '호출스택'</li>
                </a>
                <a href="./async.html">
                    <li>비동기 프로그래밍이란?</li>
                </a>
                <li>'원시자료형'</li>
            </ul>
        </div>
    </div>
    <footer>
        <div class="footer_contents">
            Copyright 2020. sangjuntechs. All rights reserved.
            <br>
            www.github.sangjuntechs.com
            <br>
            <br>
            devjun0421@gmail.com
        </div>
    </footer>

    <script src="../javascript/scrollPercent.js"></script>
    <script src="../javascript/slideMenu.js"></script>
    <script
        src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js?autoload=true&skin=sunburst&lang=css">
    </script>
</body>


</html>